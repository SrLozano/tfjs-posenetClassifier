import { EventEmitter, Component, Input, Output, NgModule } from '@angular/core';
import { tsParticles } from 'tsparticles';
import * as ɵngcc0 from '@angular/core';
export * from 'tsparticles';

class NgParticlesComponent {
    constructor() {
        this.particlesLoaded = new EventEmitter();
        this.particlesInit = new EventEmitter();
    }
    ngAfterViewInit() {
        tsParticles.init();
        this.particlesInit.emit(tsParticles);
        const cb = (container) => {
            this.particlesLoaded.emit(container);
        };
        if (this.url) {
            tsParticles.loadJSON(this.id, this.url).then(cb);
        }
        else if (this.options) {
            tsParticles.load(this.id, this.options).then(cb);
        }
        else {
            console.error('You must specify options or url to load tsParticles');
        }
    }
}
NgParticlesComponent.ɵfac = function NgParticlesComponent_Factory(t) { return new (t || NgParticlesComponent)(); };
NgParticlesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgParticlesComponent, selectors: [["ng-particles"]], inputs: { options: "options", url: "url", id: "id" }, outputs: { particlesLoaded: "particlesLoaded", particlesInit: "particlesInit" }, decls: 1, vars: 1, consts: [[3, "id"]], template: function NgParticlesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.id);
    } }, encapsulation: 2 });
NgParticlesComponent.propDecorators = {
    options: [{ type: Input }],
    url: [{ type: Input }],
    id: [{ type: Input }],
    particlesLoaded: [{ type: Output }],
    particlesInit: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgParticlesComponent, [{
        type: Component,
        args: [{
                selector: 'ng-particles',
                template: `
        <div [id]="id"></div> `
            }]
    }], function () { return []; }, { particlesLoaded: [{
            type: Output
        }], particlesInit: [{
            type: Output
        }], options: [{
            type: Input
        }], url: [{
            type: Input
        }], id: [{
            type: Input
        }] }); })();
class ParticlesComponent extends NgParticlesComponent {
    constructor() {
        super(...arguments);
        this.particlesLoaded = new EventEmitter();
        this.particlesInit = new EventEmitter();
    }
}
ParticlesComponent.ɵfac = function ParticlesComponent_Factory(t) { return ɵParticlesComponent_BaseFactory(t || ParticlesComponent); };
ParticlesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ParticlesComponent, selectors: [["Particles"]], inputs: { options: "options", url: "url", id: "id" }, outputs: { particlesLoaded: "particlesLoaded", particlesInit: "particlesInit" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [[3, "id"]], template: function ParticlesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.id);
    } }, encapsulation: 2 });
ParticlesComponent.propDecorators = {
    options: [{ type: Input }],
    url: [{ type: Input }],
    id: [{ type: Input }],
    particlesLoaded: [{ type: Output }],
    particlesInit: [{ type: Output }]
};
const ɵParticlesComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(ParticlesComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParticlesComponent, [{
        type: Component,
        args: [{
                selector: 'Particles',
                template: `
        <div [id]="id"></div> `
            }]
    }], null, { particlesLoaded: [{
            type: Output
        }], particlesInit: [{
            type: Output
        }], options: [{
            type: Input
        }], url: [{
            type: Input
        }], id: [{
            type: Input
        }] }); })();

class NgParticlesModule {
}
NgParticlesModule.ɵfac = function NgParticlesModule_Factory(t) { return new (t || NgParticlesModule)(); };
NgParticlesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgParticlesModule });
NgParticlesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgParticlesModule, { declarations: [NgParticlesComponent, ParticlesComponent], exports: [NgParticlesComponent, ParticlesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgParticlesModule, [{
        type: NgModule,
        args: [{
                declarations: [NgParticlesComponent, ParticlesComponent],
                imports: [],
                exports: [NgParticlesComponent, ParticlesComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of ng-particles
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgParticlesComponent, NgParticlesModule, ParticlesComponent };

//# sourceMappingURL=ng-particles.js.map